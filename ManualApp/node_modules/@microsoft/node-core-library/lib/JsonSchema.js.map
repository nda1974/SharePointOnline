{"version":3,"sources":["JsonSchema.ts"],"names":[],"mappings":"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","file":"JsonSchema.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as fsx from 'fs-extra';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\nimport Validator = require('z-schema');\r\n\r\nimport { JsonFile } from './JsonFile';\r\n\r\ninterface ISchemaWithId {\r\n  id: string | undefined;\r\n}\r\n\r\n/**\r\n * Callback function arguments for JsonSchema.validateObjectWithCallback();\r\n * @public\r\n */\r\nexport interface IJsonSchemaErrorInfo {\r\n  /**\r\n   * The z-schema error tree, formatted as an indented text string.\r\n   */\r\n  details: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.validateObject()\r\n * @public\r\n */\r\nexport interface IJsonSchemaValidateOptions {\r\n  /**\r\n   * A custom header that will be used to report schema errors.\r\n   * @remarks\r\n   * If omitted, the default header is \"JSON validation failed:\".  The error message starts with\r\n   * the header, followed by the full input filename, followed by the z-schema error tree.\r\n   * If you wish to customize all aspects of the error message, use JsonFile.loadAndValidateWithCallback()\r\n   * or JsonSchema.validateObjectWithCallback().\r\n   */\r\n  customErrorHeader?: string;\r\n}\r\n\r\n/**\r\n * Options for JsonSchema.fromFile()\r\n * @public\r\n */\r\nexport interface IJsonSchemaFromFileOptions {\r\n  /**\r\n   * Other schemas that this schema references, e.g. via the \"$ref\" directive.\r\n   * @remarks\r\n   * The tree of dependent schemas may reference the same schema more than once.\r\n   * However, if the same schema \"id\" is used by two different JsonSchema instances,\r\n   * an error will be reported.  This means you cannot load the same filename twice\r\n   * and use them both together, and you cannot have diamond dependencies on different\r\n   * versions of the same schema.  Although technically this would be possible to support,\r\n   * it normally indicates an error or design problem.\r\n   *\r\n   * JsonSchema also does not allow circular references between schema dependencies.\r\n   */\r\n  dependentSchemas?: JsonSchema[];\r\n}\r\n\r\n/**\r\n * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.\r\n * @remarks\r\n * The schema itself is normally loaded and compiled later, only if it is actually required to validate\r\n * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls\r\n * JsonSchema.ensureCompiled() for each of your schema objects.\r\n *\r\n * @public\r\n */\r\nexport class JsonSchema {\r\n  private _dependentSchemas: JsonSchema[] = [];\r\n  private _filename: string = '';\r\n  private _validator: Validator | undefined = undefined;\r\n  private _schemaObject: Object | undefined = undefined;\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema {\r\n    // This is a quick and inexpensive test to avoid the catch the most common errors early.\r\n    // Full validation will happen later in JsonSchema.compile().\r\n    if (!fsx.existsSync(filename)) {\r\n      throw new Error('Schema file not found: ' + filename);\r\n    }\r\n\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._filename = filename;\r\n\r\n    if (options) {\r\n      schema._dependentSchemas = options.dependentSchemas || [];\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Registers a JsonSchema that will be loaded from a file on disk.\r\n   * @remarks\r\n   * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\r\n   * until it the schema is actually used.\r\n   */\r\n  public static fromLoadedObject(schemaObject: Object): JsonSchema {\r\n    const schema: JsonSchema = new JsonSchema();\r\n    schema._schemaObject = schemaObject;\r\n    return schema;\r\n  }\r\n\r\n  private static _collectDependentSchemas(collectedSchemas: JsonSchema[], dependentSchemas: JsonSchema[],\r\n    seenObjects: Set<Object>, seenIds: Set<string>): void {\r\n\r\n    for (const dependentSchema of dependentSchemas) {\r\n      // It's okay for the same schema to appear multiple times in the tree, but we only process it once\r\n      if (seenObjects.has(dependentSchema)) {\r\n        continue;\r\n      }\r\n      seenObjects.add(dependentSchema);\r\n\r\n      const schemaId: string = dependentSchema._ensureLoaded();\r\n      if (schemaId === '') {\r\n        throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced`\r\n          + ' because is missing the \"id\" field');\r\n      }\r\n      if (seenIds.has(schemaId)) {\r\n        throw new Error(`This schema ${dependentSchema.shortName} has the same \"id\" as`\r\n        + ' another schema in this set');\r\n      }\r\n\r\n      seenIds.add(schemaId);\r\n\r\n      collectedSchemas.push(dependentSchema);\r\n\r\n      JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas,\r\n        seenObjects, seenIds);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to nicely format the ZSchema error tree.\r\n   */\r\n  private static _formatErrorDetails(errorDetails: Validator.SchemaErrorDetail[]): string {\r\n    return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');\r\n  }\r\n\r\n  /**\r\n   * Used by _formatErrorDetails.\r\n   */\r\n  private static _formatErrorDetailsHelper(errorDetails: Validator.SchemaErrorDetail[], indent: string,\r\n    buffer: string): string {\r\n    for (const errorDetail of errorDetails) {\r\n\r\n      buffer += os.EOL + indent + `Error: ${errorDetail.path}`;\r\n\r\n      if (errorDetail.description) {\r\n        const MAX_LENGTH: number = 40;\r\n        let truncatedDescription: string = errorDetail.description.trim();\r\n        if (truncatedDescription.length > MAX_LENGTH) {\r\n          truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3)\r\n            + '...';\r\n        }\r\n\r\n        buffer += ` (${truncatedDescription})`;\r\n      }\r\n\r\n      buffer += os.EOL + indent + `       ${errorDetail.message}`;\r\n\r\n      if (errorDetail.inner) {\r\n        buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Returns a short name for this schema, for use in error messages.\r\n   * @remarks\r\n   * If the schema was loaded from a file, then the base filename is used.  Otherwise, the \"id\"\r\n   * field is used if available.\r\n   */\r\n  public get shortName(): string {\r\n    if (!this._filename) {\r\n      if (this._schemaObject) {\r\n        const schemaWithId: ISchemaWithId = this._schemaObject as ISchemaWithId;\r\n        if (schemaWithId.id) {\r\n          return schemaWithId.id;\r\n        }\r\n      }\r\n      return '(anonymous schema)';\r\n    } else {\r\n      return path.basename(this._filename);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If not already done, this loads the schema from disk and compiles it.\r\n   * @remarks\r\n   * Any dependencies will be compiled as well.\r\n   */\r\n  public ensureCompiled(): void {\r\n    this._ensureLoaded();\r\n\r\n    if (!this._validator) {\r\n      // Don't assign this to _validator until we're sure everything was successful\r\n      const newValidator: Validator = new Validator({\r\n        breakOnFirstError: false,\r\n        noTypeless: true,\r\n        noExtraKeywords: true\r\n      });\r\n\r\n      const anythingSchema: Object = {\r\n        'type': [\r\n          'array',\r\n          'boolean',\r\n          'integer',\r\n          'number',\r\n          'object',\r\n          'string'\r\n        ]\r\n      };\r\n\r\n      // tslint:disable-next-line:no-any\r\n      (newValidator as any).setRemoteReference('http://json-schema.org/draft-04/schema',  anythingSchema);\r\n\r\n      const collectedSchemas: JsonSchema[] = [];\r\n      const seenObjects: Set<Object> = new Set<Object>();\r\n      const seenIds: Set<string> = new Set<string>();\r\n\r\n      JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);\r\n\r\n      // Validate each schema in order.  We specifically do not supply them all together, because we want\r\n      // to make sure that circular references will fail to validate.\r\n      for (const collectedSchema of collectedSchemas) {\r\n        if (!newValidator.validateSchema(collectedSchema._schemaObject)) {\r\n          throw new Error(`Failed to validate schema \"${collectedSchema.shortName}\":` + os.EOL\r\n            + JsonSchema._formatErrorDetails(newValidator.getLastErrors()));\r\n        }\r\n      }\r\n\r\n      this._validator = newValidator;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * an exception will be thrown.\r\n   * @param jsonObject - The JSON data to be validated\r\n   * @param filenameForErrors - The filename that the JSON data was available, or an empty string\r\n   *    if not applicable\r\n   * @param options - Other options that control the validation\r\n   */\r\n  public validateObject(jsonObject: Object, filenameForErrors: string, options?: IJsonSchemaValidateOptions): void {\r\n    this.validateObjectWithCallback(jsonObject, (errorInfo: IJsonSchemaErrorInfo) => {\r\n      const prefix: string = (options && options.customErrorHeader) ? options.customErrorHeader\r\n        : 'JSON validation failed:';\r\n\r\n      throw new Error(prefix + os.EOL +\r\n        filenameForErrors + os.EOL + errorInfo.details);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validates the specified JSON object against this JSON schema.  If the validation fails,\r\n   * a callback is called for each validation error.\r\n   */\r\n  public validateObjectWithCallback(jsonObject: Object,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): void {\r\n\r\n    this.ensureCompiled();\r\n\r\n    if (!this._validator!.validate(jsonObject, this._schemaObject)) {\r\n      const errorDetails: string = JsonSchema._formatErrorDetails(this._validator!.getLastErrors());\r\n\r\n      const args: IJsonSchemaErrorInfo = {\r\n        details: errorDetails\r\n      };\r\n      errorCallback(args);\r\n    }\r\n  }\r\n\r\n  private constructor() {\r\n  }\r\n\r\n  private _ensureLoaded(): string {\r\n    if (!this._schemaObject) {\r\n      this._schemaObject = JsonFile.load(this._filename);\r\n    }\r\n    return (this._schemaObject as ISchemaWithId).id || '';\r\n  }\r\n}\r\n"],"sourceRoot":"..\\src"}