"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var fsx = require("fs-extra");
var os = require("os");
var jju = require("jju");
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
var JsonFile = (function () {
    function JsonFile() {
    }
    /**
     * Loads a JSON file.
     */
    JsonFile.load = function (jsonFilename) {
        if (!fsx.existsSync(jsonFilename)) {
            throw new Error("Input file not found: " + jsonFilename);
        }
        var buffer = fsx.readFileSync(jsonFilename);
        try {
            return jju.parse(buffer.toString());
        }
        catch (error) {
            throw new Error("Error reading \"" + jsonFilename + "\":" + os.EOL + ("  " + error.message));
        }
    };
    /**
     * Loads a JSON file and validate its schema.
     */
    JsonFile.loadAndValidate = function (jsonFilename, jsonSchema, options) {
        var jsonObject = JsonFile.load(jsonFilename); // tslint:disable-line:no-any
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    };
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    JsonFile.loadAndValidateWithCallback = function (jsonFilename, jsonSchema, errorCallback) {
        var jsonObject = JsonFile.load(jsonFilename); // tslint:disable-line:no-any
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    };
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    JsonFile.stringify = function (jsonObject, options) {
        JsonFile.validateNoUndefinedMembers(jsonObject);
        var stringified = JSON.stringify(jsonObject, undefined, 2) + '\n';
        if (options && options.unixNewlines) {
            return stringified;
        }
        else {
            return JsonFile._getAllReplaced(stringified, '\n', '\r\n');
        }
    };
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    JsonFile.save = function (jsonObject, jsonFilename, options) {
        if (options === void 0) { options = {}; }
        var normalized = JsonFile.stringify(jsonObject, options);
        var buffer = new Buffer(normalized); // utf8 encoding happens here
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (fsx.existsSync(jsonFilename)) {
                try {
                    var oldBuffer = fsx.readFileSync(jsonFilename);
                    if (Buffer.compare(buffer, oldBuffer) === 0) {
                        // Nothing has changed, so don't touch the file
                        return false;
                    }
                }
                catch (error) {
                    // Ignore this error, and try writing a new file.  If that fails, then we should report that
                    // error instead.
                }
            }
        }
        fsx.writeFileSync(jsonFilename, buffer);
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = fsx.readFileSync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    };
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    // tslint:disable-next-line:no-any
    JsonFile.validateNoUndefinedMembers = function (jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    };
    // Private implementation of validateNoUndefinedMembers()
    JsonFile._validateNoUndefinedMembers = function (jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (var _i = 0, _a = Object.keys(jsonObject); _i < _a.length; _i++) {
                var key = _a[_i];
                keyPath.push(key);
                // tslint:disable-next-line:no-any
                var value = jsonObject[key];
                if (value === undefined) {
                    var fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error("The value for " + fullPath + " is undefined");
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    };
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    JsonFile._formatKeyPath = function (keyPath) {
        var result = '';
        for (var _i = 0, keyPath_1 = keyPath; _i < keyPath_1.length; _i++) {
            var key = keyPath_1[_i];
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += "[" + key + "]";
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += "" + key;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                var escapedKey = key.replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += "[\"" + escapedKey + "\"]";
            }
        }
        return result;
    };
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param targetString  The string to be modified
     * @param searchValue   The value to search for
     * @param replaceValue  The replacement text
     */
    JsonFile._getAllReplaced = function (targetString, searchValue, replaceValue) {
        return targetString.split(searchValue).join(replaceValue);
    };
    return JsonFile;
}());
exports.JsonFile = JsonFile;

//# sourceMappingURL=JsonFile.js.map
