"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var fsx = require("fs-extra");
var os = require("os");
var path = require("path");
var Validator = require("z-schema");
var JsonFile_1 = require("./JsonFile");
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
var JsonSchema = (function () {
    function JsonSchema() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    JsonSchema.fromFile = function (filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!fsx.existsSync(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        var schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    };
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    JsonSchema.fromLoadedObject = function (schemaObject) {
        var schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    };
    JsonSchema._collectDependentSchemas = function (collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (var _i = 0, dependentSchemas_1 = dependentSchemas; _i < dependentSchemas_1.length; _i++) {
            var dependentSchema = dependentSchemas_1[_i];
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            var schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error("This schema " + dependentSchema.shortName + " cannot be referenced"
                    + ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error("This schema " + dependentSchema.shortName + " has the same \"id\" as"
                    + ' another schema in this set');
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    };
    /**
     * Used to nicely format the ZSchema error tree.
     */
    JsonSchema._formatErrorDetails = function (errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    };
    /**
     * Used by _formatErrorDetails.
     */
    JsonSchema._formatErrorDetailsHelper = function (errorDetails, indent, buffer) {
        for (var _i = 0, errorDetails_1 = errorDetails; _i < errorDetails_1.length; _i++) {
            var errorDetail = errorDetails_1[_i];
            buffer += os.EOL + indent + ("Error: " + errorDetail.path);
            if (errorDetail.description) {
                var MAX_LENGTH = 40;
                var truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3)
                        + '...';
                }
                buffer += " (" + truncatedDescription + ")";
            }
            buffer += os.EOL + indent + ("       " + errorDetail.message);
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    };
    Object.defineProperty(JsonSchema.prototype, "shortName", {
        /**
         * Returns a short name for this schema, for use in error messages.
         * @remarks
         * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
         * field is used if available.
         */
        get: function () {
            if (!this._filename) {
                if (this._schemaObject) {
                    var schemaWithId = this._schemaObject;
                    if (schemaWithId.id) {
                        return schemaWithId.id;
                    }
                }
                return '(anonymous schema)';
            }
            else {
                return path.basename(this._filename);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    JsonSchema.prototype.ensureCompiled = function () {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            var newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            var anythingSchema = {
                'type': [
                    'array',
                    'boolean',
                    'integer',
                    'number',
                    'object',
                    'string'
                ]
            };
            // tslint:disable-next-line:no-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            var collectedSchemas = [];
            var seenObjects = new Set();
            var seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (var _i = 0, collectedSchemas_1 = collectedSchemas; _i < collectedSchemas_1.length; _i++) {
                var collectedSchema = collectedSchemas_1[_i];
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error("Failed to validate schema \"" + collectedSchema.shortName + "\":" + os.EOL
                        + JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    };
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    JsonSchema.prototype.validateObject = function (jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, function (errorInfo) {
            var prefix = (options && options.customErrorHeader) ? options.customErrorHeader
                : 'JSON validation failed:';
            throw new Error(prefix + os.EOL +
                filenameForErrors + os.EOL + errorInfo.details);
        });
    };
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    JsonSchema.prototype.validateObjectWithCallback = function (jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            var errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            var args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    };
    JsonSchema.prototype._ensureLoaded = function () {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    };
    return JsonSchema;
}());
exports.JsonSchema = JsonSchema;

//# sourceMappingURL=JsonSchema.js.map
