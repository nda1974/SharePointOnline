{"version":3,"sources":["JsonFile.ts"],"names":[],"mappings":"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","file":"JsonFile.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as fsx from 'fs-extra';\r\nimport * as os from 'os';\r\nimport * as jju from 'jju';\r\n\r\nimport { JsonSchema, IJsonSchemaErrorInfo, IJsonSchemaValidateOptions } from './JsonSchema';\r\n\r\n/**\r\n * Options for JsonFile.stringify()\r\n *\r\n * @public\r\n */\r\nexport interface IJsonFileStringifyOptions {\r\n  /**\r\n   * If true, then \"\\n\" will be used for newlines instead of the default \"\\r\\n\".\r\n   */\r\n  unixNewlines?: boolean;\r\n}\r\n\r\n/**\r\n * Options for JsonFile.saveJsonFile()\r\n *\r\n * @public\r\n */\r\nexport interface IJsonFileSaveOptions extends IJsonFileStringifyOptions {\r\n  /**\r\n   * If there is an existing file, and the contents have not changed, then\r\n   * don't write anything; this preserves the old timestamp.\r\n   */\r\n  onlyIfChanged?: boolean;\r\n}\r\n\r\n/**\r\n * Utilities for reading/writing JSON files.\r\n * @public\r\n */\r\nexport class JsonFile {\r\n  /**\r\n   * Loads a JSON file.\r\n   */\r\n  public static load(jsonFilename: string): any { // tslint:disable-line:no-any\r\n    if (!fsx.existsSync(jsonFilename)) {\r\n      throw new Error(`Input file not found: ${jsonFilename}`);\r\n    }\r\n\r\n    const buffer: Buffer = fsx.readFileSync(jsonFilename);\r\n    try {\r\n      return jju.parse(buffer.toString());\r\n    } catch (error) {\r\n      throw new Error(`Error reading \"${jsonFilename}\":` + os.EOL + `  ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loads a JSON file and validate its schema.\r\n   */\r\n  public static loadAndValidate(jsonFilename: string, jsonSchema: JsonSchema,\r\n    options?: IJsonSchemaValidateOptions): any { // tslint:disable-line:no-any\r\n\r\n    const jsonObject: any = JsonFile.load(jsonFilename); // tslint:disable-line:no-any\r\n    jsonSchema.validateObject(jsonObject, jsonFilename, options);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * Loads a JSON file and validate its schema, reporting errors using a callback\r\n   * @remarks\r\n   * See JsonSchema.validateObjectWithCallback() for more info.\r\n   */\r\n  public static loadAndValidateWithCallback(jsonFilename: string, jsonSchema: JsonSchema,\r\n    errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): any { // tslint:disable-line:no-any\r\n\r\n    const jsonObject: any = JsonFile.load(jsonFilename); // tslint:disable-line:no-any\r\n    jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);\r\n\r\n    return jsonObject;\r\n  }\r\n\r\n  /**\r\n   * Serializes the specified JSON object to a string buffer.\r\n   * @param jsonObject - the object to be serialized\r\n   * @param options - other settings that control serialization\r\n   * @returns a JSON string, with newlines, and indented with two spaces\r\n   */\r\n  public static stringify(jsonObject: Object, options?: IJsonFileStringifyOptions): string {\r\n    JsonFile.validateNoUndefinedMembers(jsonObject);\r\n    const stringified: string = JSON.stringify(jsonObject, undefined, 2) + '\\n';\r\n\r\n    if (options && options.unixNewlines) {\r\n      return stringified;\r\n    } else {\r\n      return JsonFile._getAllReplaced(stringified, '\\n', '\\r\\n');\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.\r\n   * @param jsonObject - the object to be saved\r\n   * @param jsonFilename - the file path to write\r\n   * @param options - other settings that control how the file is saved\r\n   * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise\r\n   */\r\n  public static save(jsonObject: Object, jsonFilename: string, options: IJsonFileSaveOptions = {}): boolean {\r\n    const normalized: string = JsonFile.stringify(jsonObject, options);\r\n\r\n    const buffer: Buffer = new Buffer(normalized); // utf8 encoding happens here\r\n\r\n    if (options.onlyIfChanged) {\r\n      // Has the file changed?\r\n      if (fsx.existsSync(jsonFilename)) {\r\n        try {\r\n          const oldBuffer: Buffer = fsx.readFileSync(jsonFilename);\r\n          if (Buffer.compare(buffer, oldBuffer) === 0) {\r\n            // Nothing has changed, so don't touch the file\r\n            return false;\r\n          }\r\n        } catch (error) {\r\n          // Ignore this error, and try writing a new file.  If that fails, then we should report that\r\n          // error instead.\r\n        }\r\n      }\r\n    }\r\n\r\n    fsx.writeFileSync(jsonFilename, buffer);\r\n\r\n    // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.\r\n    /*\r\n    const oldBuffer2: Buffer = fsx.readFileSync(jsonFilename);\r\n    if (Buffer.compare(buffer, oldBuffer2) !== 0) {\r\n      console.log('new:' + buffer.toString('hex'));\r\n      console.log('old:' + oldBuffer2.toString('hex'));\r\n\r\n      throw new Error('onlyIfChanged logic is broken');\r\n    }\r\n    */\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Used to validate a data structure before writing.  Reports an error if there\r\n   * are any undefined members.\r\n   */\r\n  // tslint:disable-next-line:no-any\r\n  public static validateNoUndefinedMembers(jsonObject: Object): void {\r\n    if (!jsonObject) {\r\n      return;\r\n    }\r\n    if (typeof jsonObject === 'object') {\r\n      for (const key of Object.keys(jsonObject)) {\r\n        // tslint:disable-next-line:no-any\r\n        const value: any = jsonObject[key];\r\n        if (value === undefined) {\r\n          throw new Error(`The key \"${key}\" is undefined`);\r\n        }\r\n        JsonFile.validateNoUndefinedMembers(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\r\n   * all matches are replaced, rather than just the first match.\r\n   * @param targetString  The string to be modified\r\n   * @param searchValue   The value to search for\r\n   * @param replaceValue  The replacement text\r\n   */\r\n  private static _getAllReplaced(targetString: string, searchValue: string, replaceValue: string): string {\r\n    return targetString.split(searchValue).join(replaceValue);\r\n  }\r\n}\r\n"],"sourceRoot":"..\\src"}