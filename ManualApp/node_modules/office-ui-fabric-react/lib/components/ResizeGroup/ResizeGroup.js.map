{"version":3,"file":"ResizeGroup.js","sourceRoot":"../src/","sources":["components/ResizeGroup/ResizeGroup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  css,\n  BaseComponent\n} from '../../Utilities';\nimport { IResizeGroupProps } from './ResizeGroup.Props';\nimport styles = require('./ResizeGroup.scss');\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n\n  /**\n   * Final data used to render proper sized component\n  */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    }\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerWidth: number | undefined;\n\n  /**\n   * Gets the width of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\n   * is not in the cache.\n   */\n  function _getMeasuredWidth(measuredData: any, getElementToMeasureWidth: () => number): number {\n    let cachedWidth = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedWidth !== undefined) {\n      return cachedWidth;\n    }\n\n    let measuredWidth = getElementToMeasureWidth();\n    _measurementCache.addMeasurementToCache(measuredData, measuredWidth);\n    return measuredWidth;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width.\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\n   * is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureWidth: () => number): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredWidth: number | undefined = _getMeasuredWidth(data, getElementToMeasureWidth);\n\n    while (measuredWidth > _containerWidth!) {\n      let nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredWidth === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink'\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\n   * is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureWidth: () => number): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredWidth: number | undefined = _getMeasuredWidth(data, getElementToMeasureWidth);\n\n    while (measuredWidth < _containerWidth!) {\n      let nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredWidth === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      dataToMeasure,\n      resizeDirection: 'shrink'\n    };\n  }\n\n  /**\n   * Handles an update to the container width. Should only be called when we knew the previous container width.\n   * @param newWidth - The new width of the container.\n   * @param fullWidthData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerWidth(newWidth: number, fullWidthData: any, renderedData: any, onGrowData?: (prevData: any) => any): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newWidth > _containerWidth!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData)\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullWidthData\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData\n      };\n    }\n    _containerWidth = newWidth;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureWidth: () => number,\n    newContainerWidth?: number): IResizeGroupState | undefined {\n    // If there is no new container width or data to measure, there is no need for a new state update\n    if (newContainerWidth === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerWidth) {\n      // If we know what the last container size was and we rendered data at that width, we can do an optimized render\n      if (_containerWidth && currentState.renderedData && !currentState.dataToMeasure) {\n        return { ...currentState, ..._updateContainerWidth(newContainerWidth, props.data, currentState.renderedData, props.onGrowData) };\n      }\n\n      // If we are just setting the container width for the first time, we can't do any optimizations\n      _containerWidth = newContainerWidth;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureWidth)\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureWidth)\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  function shouldRenderDataToMeasureInHiddenDiv(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataToMeasureInHiddenDiv\n  };\n};\n\nexport class ResizeGroup extends BaseComponent<IResizeGroupProps, IResizeGroupState> {\n  private _nextResizeGroupStateProvider = getNextResizeGroupStateProvider();\n  private _root: HTMLElement;\n  private _measured: HTMLElement;\n\n  constructor(props: IResizeGroupProps) {\n    super(props);\n    this.state = {\n      dataToMeasure: { ...this.props.data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  public render() {\n    const { onRenderData } = this.props;\n    const { dataToMeasure, renderedData } = this.state;\n\n    return (\n      <div className={ css('ms-ResizeGroup') } ref={ this._resolveRef('_root') }>\n        { this._nextResizeGroupStateProvider.shouldRenderDataToMeasureInHiddenDiv(dataToMeasure) && (\n          <div className={ css(styles.measured) } ref={ this._resolveRef('_measured') }>\n            { onRenderData(dataToMeasure) }\n          </div>\n        ) }\n\n        { renderedData && onRenderData(renderedData) }\n      </div>\n    );\n  }\n\n  public componentDidMount() {\n    this._afterComponentRendered();\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));\n  }\n\n  public componentWillReceiveProps(nextProps: IResizeGroupProps) {\n    this.setState({\n      dataToMeasure: { ...nextProps.data },\n      resizeDirection: 'grow',\n      measureContainer: true // Receiving new props means the parent might rerender and the root width might change\n    });\n  }\n\n  public componentDidUpdate(prevProps: IResizeGroupProps) {\n    if (this.state.renderedData) {\n      if (this.props.dataDidRender) {\n        this.props.dataDidRender(this.state.renderedData);\n      }\n    }\n    this._afterComponentRendered();\n  }\n\n  private _afterComponentRendered() {\n    this._async.requestAnimationFrame(() => {\n      let containerWidth = undefined;\n      if (this.state.measureContainer) {\n        containerWidth = this._root.getBoundingClientRect().width;\n      }\n      let nextState = this._nextResizeGroupStateProvider.getNextState(this.props,\n        this.state,\n        () => this._measured.scrollWidth,\n        containerWidth);\n\n      if (nextState) {\n        this.setState(nextState);\n      }\n    });\n  }\n\n  private _onResize() {\n    if (this._root) {\n      this.setState({ measureContainer: true });\n    }\n  }\n}"]}