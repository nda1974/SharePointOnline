{"version":3,"file":"ConnectedHost.js","sourceRoot":"../src/","sources":["common/ConnectedHost.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { ISubscribable } from './ISubscribable';\nimport { BaseComponent, autobind, assign, shallowCompare } from '../Utilities';\nimport { IStoreKey } from './storeKey';\nimport { StoreSet } from './StoreSet';\n\n// Track all components that require changes.\nlet _changedComponents: ConnectedHost[] | null;\n\nexport interface IConnectedHostProps {\n  componentRef?: () => void;\n  componentProps: any;\n  storesToSubscribe: IStoreKey[];\n  component: any;\n  getProps: (stores: any, props: any) => any;\n}\n\nexport interface IConnectedHostState {\n  props: any;\n}\n\nexport class ConnectedHost extends BaseComponent<IConnectedHostProps, IConnectedHostState> {\n  public static contextTypes = {\n    stores: PropTypes.object\n  };\n\n  public context: {\n    stores: StoreSet;\n  };\n\n  private _stores: ISubscribable[];\n  private _changeEnqueued: boolean;\n  private _isMounted: boolean;\n\n  constructor(props: IConnectedHostProps) {\n    super(props);\n\n    this.state = {\n      props: null\n    };\n  }\n\n  public componentWillMount() {\n    if (this.props.storesToSubscribe && this.props.storesToSubscribe.length > 0) {\n      if (!this.context.stores) {\n        throw `A connected component was hosted in an environment where no stores were hosted. Use the StoreHost to host components.`;\n      }\n\n      // Resolve and subscribe to stores.\n      this._stores = this.props.storesToSubscribe.map(storeKey => {\n        let store = this.context.stores.getStore(storeKey);\n\n        if (!store) {\n          throw `The \"${storeKey.name}\" store was required by a connected component, but not exposed.`;\n        }\n        this._disposables.push(store.subscribe(this._onStoreChanged));\n\n        return store;\n      });\n    }\n\n    // We can only initialize state at this point, where context has been resolved.\n    this.state = {\n      props: this._getComponentProps(this.props)\n    };\n  }\n\n  public componentDidMount() {\n    this._isMounted = true;\n  }\n\n  public componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  public componentWillReceiveProps(newProps: IConnectedHostProps) {\n    this._updateProps(newProps);\n  }\n\n  public shouldComponentUpdate(newProps: IConnectedHostProps, newState: IConnectedHostState) {\n    let inputPropsHaveChanged = !shallowCompare(this.props.componentProps, newProps.componentProps);\n    let computedPropsHaveChanged = !shallowCompare(this.state.props, newState.props);\n    let shouldUpdate = inputPropsHaveChanged || computedPropsHaveChanged;\n\n    return shouldUpdate;\n  }\n\n  public render() {\n    let { component: Component } = this.props;\n    let { props } = this.state;\n\n    return props ? <Component { ...props } /> : null;\n  }\n\n  @autobind\n  private _onStoreChanged() {\n    let { storesToSubscribe } = this.props;\n\n    if (!storesToSubscribe || storesToSubscribe.length < 2) {\n      this._updateProps();\n    } else if (!this._changeEnqueued) {\n      if (!_changedComponents) {\n        _changedComponents = [];\n        this._async.setImmediate(() => {\n          _changedComponents!.forEach(comp => comp._updateProps());\n          _changedComponents = null;\n        });\n      }\n      _changedComponents.push(this);\n      this._changeEnqueued = true;\n    }\n  }\n\n  @autobind\n  private _updateProps(props?: any) {\n    this._changeEnqueued = false;\n    props = this._getComponentProps(props || this.props);\n    this.setState({ props });\n  }\n\n  private _getComponentProps(props: any) {\n    let newProps = assign(\n      {},\n      props.componentProps,\n      props.getProps(props.componentProps, ...this._stores));\n\n    return newProps;\n  }\n}\n"]}