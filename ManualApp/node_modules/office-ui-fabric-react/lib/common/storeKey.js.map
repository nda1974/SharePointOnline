{"version":3,"file":"storeKey.js","sourceRoot":"../src/","sources":["common/storeKey.ts"],"names":[],"mappings":";;AAAA,0CAAqC;AAOrC;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACU,QAAA,QAAQ,GAAG,UAAC,IAAY,IAAK,OAAA,CAAC,EAAE,IAAI,MAAA,EAAE,EAAE,EAAE,iBAAK,CAAC,IAAI,CAAC,EAAE,CAAc,EAAxC,CAAwC,CAAC","sourcesContent":["import { getId } from '../Utilities';\n\nexport interface IStoreKey {\n  name: string;\n  id: string;\n}\n\n/**\n * Store keys are a very simple abstraction that maps a string name to an interface type.\n * The enables a type-safe contract for store dependencies when you connect dumb components\n * to stores.\n *\n * @example\n * let selectionKey = storeKey<ISelection>('selection');\n *\n * let stores = new StoreSet()\n *   .add(selectionKey, new Selection());\n *\n * <StoreHost stores={ stores }>\n *   ...\n * </StoreHost>\n *\n * connect(DumbComponent, [ selectionKey ], (props, selection) => ({\n *   isSelected: selection.getSelected(props.item.key)\n * });\n *\n * Note that the \"selection\" reference in the connect callback would be of type ISelection due\n * to the selectionKey reference, and you will get TypeScript errors by referring to selection\n * member that aren't in that interface.\n */\nexport const storeKey = (name: string) => ({ name, id: getId(name) }) as IStoreKey;\n"]}