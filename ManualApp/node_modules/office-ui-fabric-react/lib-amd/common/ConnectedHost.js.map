{"version":3,"file":"ConnectedHost.js","sourceRoot":"../src/","sources":["common/ConnectedHost.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { ISubscribable } from './ISubscribable';\nimport { BaseComponent, autobind, assign, shallowCompare } from '../Utilities';\nimport { IStoreKey } from './storeKey';\nimport { StoreSet } from './StoreSet';\n\n// Track all components that require changes.\nlet _changedComponents: ConnectedHost[] | null;\n\nexport interface IConnectedHostProps {\n  componentRef?: () => void;\n  componentProps: any;\n  storesToSubscribe: IStoreKey[];\n  component: any;\n  getProps: (stores: any, props: any) => any;\n}\n\nexport interface IConnectedHostState {\n  props: any;\n}\n\nexport class ConnectedHost extends BaseComponent<IConnectedHostProps, IConnectedHostState> {\n  public static contextTypes = {\n    stores: PropTypes.object\n  };\n\n  public context: {\n    stores: StoreSet;\n  };\n\n  private _stores: ISubscribable[];\n  private _changeEnqueued: boolean;\n  private _isMounted: boolean;\n\n  constructor(props: IConnectedHostProps) {\n    super(props);\n\n    this.state = {\n      props: null\n    };\n  }\n\n  public componentWillMount() {\n    if (this.props.storesToSubscribe && this.props.storesToSubscribe.length > 0) {\n      if (!this.context.stores) {\n        throw `A connected component was hosted in an environment where no stores were hosted. Use the StoreHost to host components.`;\n      }\n\n      // Resolve and subscribe to stores.\n      this._stores = this.props.storesToSubscribe.map(storeKey => {\n        let store = this.context.stores.getStore(storeKey);\n\n        if (!store) {\n          throw `The \"${storeKey.name}\" store was required by a connected component, but not exposed.`;\n        }\n        this._disposables.push(store.subscribe(this._onStoreChanged));\n\n        return store;\n      });\n    }\n\n    // We can only initialize state at this point, where context has been resolved.\n    this.state = {\n      props: this._getComponentProps(this.props)\n    };\n  }\n\n  public componentDidMount() {\n    this._isMounted = true;\n  }\n\n  public componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  public componentWillReceiveProps(newProps: IConnectedHostProps) {\n    this._updateProps(newProps);\n  }\n\n  public shouldComponentUpdate(newProps: IConnectedHostProps, newState: IConnectedHostState) {\n    let inputPropsHaveChanged = !shallowCompare(this.props.componentProps, newProps.componentProps);\n    let computedPropsHaveChanged = !shallowCompare(this.state.props, newState.props);\n    let shouldUpdate = inputPropsHaveChanged || computedPropsHaveChanged;\n\n    return shouldUpdate;\n  }\n\n  public render() {\n    let { component: Component } = this.props;\n    let { props } = this.state;\n\n    return props ? <Component { ...props } /> : null;\n  }\n\n  @autobind\n  private _onStoreChanged() {\n    let { storesToSubscribe } = this.props;\n\n    if (!storesToSubscribe || storesToSubscribe.length < 2) {\n      this._updateProps();\n    } else if (!this._changeEnqueued) {\n      if (!_changedComponents) {\n        _changedComponents = [];\n        this._async.setImmediate(() => {\n          _changedComponents!.forEach(comp => comp._updateProps());\n          _changedComponents = null;\n        });\n      }\n      _changedComponents.push(this);\n      this._changeEnqueued = true;\n    }\n  }\n\n  @autobind\n  private _updateProps(props?: any) {\n    this._changeEnqueued = false;\n    props = this._getComponentProps(props || this.props);\n    this.setState({ props });\n  }\n\n  private _getComponentProps(props: any) {\n    let newProps = assign(\n      {},\n      props.componentProps,\n      props.getProps(props.componentProps, ...this._stores));\n\n    return newProps;\n  }\n}\n"]}