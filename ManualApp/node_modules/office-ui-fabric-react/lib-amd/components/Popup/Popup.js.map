{"version":3,"file":"Popup.js","sourceRoot":"../src/","sources":["components/Popup/Popup.tsx"],"names":[],"mappings":";;;IAYA;;OAEG;IACH;QAA2B,iCAA8B;QAAzD;;QAkFA,CAAC;QApEQ,kCAAkB,GAAzB;YACE,IAAI,CAAC,uBAAuB,GAAG,uBAAW,EAAG,CAAC,aAA4B,CAAC;QAC7E,CAAC;QAEM,iCAAiB,GAAxB;YACE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAC9D,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YAC5D,EAAE,CAAC,CAAC,mCAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC5C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YAC7B,CAAC;QACH,CAAC;QAEM,oCAAoB,GAA3B;YACE,EAAE,CAAC,CACD,IAAI,CAAC,KAAK,CAAC,kBAAkB;gBAC7B,IAAI,CAAC,uBAAuB;gBAC5B,IAAI,CAAC,cAAc;gBACnB,IAAI,CAAC,uBAA8B,KAAK,MAAM,CAAC,CAAC,CAAC;gBACjD,4GAA4G;gBAC5G,8GAA8G;gBAC9G,2EAA2E;gBAC3E,EAAE,CAAC,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,CAAC;gBACvC,CAAC;YACH,CAAC;QACH,CAAC;QAEM,sBAAM,GAAb;YACM,IAAA,eAA4E,EAA1E,cAAI,EAAE,wBAAS,EAAE,wBAAS,EAAE,kCAAc,EAAE,oCAAe,CAAgB;YAEjF,MAAM,CAAC,CACL,8CACE,GAAG,EAAC,MAAM,IACL,0BAAc,CAAC,IAAI,CAAC,KAAK,EAAE,yBAAa,CAAC,IAC9C,SAAS,EAAG,SAAS,EACrB,IAAI,EAAG,IAAI,gBACE,SAAS,qBACJ,cAAc,sBACb,eAAe,EAClC,SAAS,EAAG,IAAI,CAAC,UAAU,KACzB,IAAI,CAAC,KAAK,CAAC,QAAQ,CACjB,CACP,CAAC;QACJ,CAAC;QAGO,0BAAU,GAAlB,UAAmB,EAAoC;YACrD,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;gBACjB;oBAEE,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;wBACzB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;wBAEzB,EAAE,CAAC,cAAc,EAAE,CAAC;wBACpB,EAAE,CAAC,eAAe,EAAE,CAAC;oBACvB,CAAC;oBAED,KAAK,CAAC;YACV,CAAC;QACH,CAAC;QAEO,wBAAQ,GAAhB;YACE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC7B,CAAC;QAEO,uBAAO,GAAf;YACE,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC9B,CAAC;QA/Ea,kBAAY,GAAgB;YACxC,kBAAkB,EAAE,IAAI;SACzB,CAAC;QAwDF;YADC,oBAAQ;+CAcR;QASH,YAAC;KAAA,AAlFD,CAA2B,yBAAa,GAkFvC;IAlFY,sBAAK","sourcesContent":["import * as React from 'react';\nimport {\n  BaseComponent,\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  autobind\n} from '../../Utilities';\nimport { IPopupProps } from './Popup.Props';\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport class Popup extends BaseComponent<IPopupProps, {}> {\n\n  public static defaultProps: IPopupProps = {\n    shouldRestoreFocus: true\n  };\n\n  public refs: {\n    [key: string]: React.ReactInstance;\n    root: HTMLElement;\n  };\n\n  private _originalFocusedElement: HTMLElement;\n  private _containsFocus: boolean;\n\n  public componentWillMount() {\n    this._originalFocusedElement = getDocument()!.activeElement as HTMLElement;\n  }\n\n  public componentDidMount(): void {\n    this._events.on(this.refs.root, 'focus', this._onFocus, true);\n    this._events.on(this.refs.root, 'blur', this._onBlur, true);\n    if (doesElementContainFocus(this.refs.root)) {\n      this._containsFocus = true;\n    }\n  }\n\n  public componentWillUnmount(): void {\n    if (\n      this.props.shouldRestoreFocus &&\n      this._originalFocusedElement &&\n      this._containsFocus &&\n      this._originalFocusedElement as any !== window) {\n      // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\n      // to reset the focus back to the thing it thinks should have been focused.\n      if (this._originalFocusedElement) {\n        this._originalFocusedElement.focus();\n      }\n    }\n  }\n\n  public render() {\n    let { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy } = this.props;\n\n    return (\n      <div\n        ref='root'\n        { ...getNativeProps(this.props, divProperties) }\n        className={ className }\n        role={ role }\n        aria-label={ ariaLabel }\n        aria-labelledby={ ariaLabelledBy }\n        aria-describedby={ ariaDescribedBy }\n        onKeyDown={ this._onKeyDown }>\n        { this.props.children }\n      </div>\n    );\n  }\n\n  @autobind\n  private _onKeyDown(ev: React.KeyboardEvent<HTMLElement>) {\n    switch (ev.which) {\n      case KeyCodes.escape:\n\n        if (this.props.onDismiss) {\n          this.props.onDismiss(ev);\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        break;\n    }\n  }\n\n  private _onFocus() {\n    this._containsFocus = true;\n  }\n\n  private _onBlur() {\n    this._containsFocus = false;\n  }\n}\n"]}