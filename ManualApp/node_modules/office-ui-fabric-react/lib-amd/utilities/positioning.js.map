{"version":3,"file":"positioning.js","sourceRoot":"../src/","sources":["utilities/positioning.ts"],"names":[],"mappings":"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","sourcesContent":["import { DirectionalHint } from '../common/DirectionalHint';\nimport {\n  IRectangle,\n  assign,\n  getScrollbarWidth,\n  Rectangle,\n  getRTL,\n} from '../Utilities';\n\nexport enum RectangleEdge {\n  top = 0,\n  bottom = 1,\n  left = 2,\n  right = 3\n}\n\nexport enum Position {\n  top = 0,\n  bottom = 1,\n  start = 2,\n  end = 3\n}\n\nlet SLIDE_ANIMATIONS: { [key: number]: string; } = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20'\n};\n\nexport interface IPositionProps {\n\n  target?: HTMLElement | MouseEvent;\n\n  /** Deprecated at v1.0.0, use 'target' instead.\n   * @deprecated\n   */\n  targetElement?: HTMLElement;\n\n  /** how the element should be positioned */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /** The gap between the callout and the target */\n  gapSpace?: number;\n\n  /** The width of the beak. */\n  beakWidth?: number;\n\n  /**\n   * The bounding rectangle for which  the contextual menu can appear in.\n   */\n  bounds?: IRectangle;\n\n  /**\n   * Deprecated at v1.0.0, use 'target' with event passed in.\n   * @deprecated\n   * @default null\n   */\n  creationEvent?: MouseEvent;\n\n  /**\n   * Deprecated at v1.0.0, use 'target' with event passed in.\n   * @deprecated\n   */\n  useTargetPoint?: boolean;\n\n  /**\n   * Deprecated at v1.0.0, use 'target' with event passed in.\n   * @deprecated\n   */\n  targetPoint?: IPoint;\n\n  /** If true then the beak is visible. If false it will not be shown. */\n  isBeakVisible?: boolean;\n\n  /**\n   * If true the position returned will have the menu element cover the target.\n   * If false then it will position next to the target;\n   */\n  coverTarget?: boolean;\n\n  /**\n   * If true the position will not change edges in an attempt to fit the rectangle within bounds.\n   * It will still attempt to align it to whatever bounds are given.\n   * @default false\n   */\n  directionalHintFixed?: boolean;\n}\n\nexport interface IPositionInfo {\n  calloutPosition: { top: number, left: number };\n  beakPosition: { top: number, left: number, display: string };\n  directionalClassName: string;\n  submenuDirection: DirectionalHint;\n}\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\nexport class PositionData {\n  public calloutDirection: RectangleEdge;\n  public targetDirection: RectangleEdge;\n  public calloutPercent: number;\n  public targetPercent: number;\n  public beakPercent: number;\n  public isAuto: boolean;\n\n  constructor(calloutDirection: RectangleEdge, targetDirection: RectangleEdge, calloutPercent: number, targetPercent: number, beakPercent: number, isAuto: boolean) {\n    this.calloutDirection = calloutDirection;\n    this.targetDirection = targetDirection;\n    this.calloutPercent = calloutPercent;\n    this.targetPercent = targetPercent;\n    this.beakPercent = beakPercent;\n    this.isAuto = isAuto;\n  }\n}\n\nlet MirrorDirectionalHintDictionary: { [key: number]: DirectionalHint } = {\n  [DirectionalHint.topLeftEdge]: DirectionalHint.topRightEdge,\n  [DirectionalHint.topCenter]: DirectionalHint.topCenter,\n  [DirectionalHint.topRightEdge]: DirectionalHint.topLeftEdge,\n  [DirectionalHint.topAutoEdge]: DirectionalHint.topAutoEdge,\n  [DirectionalHint.bottomLeftEdge]: DirectionalHint.bottomRightEdge,\n  [DirectionalHint.bottomCenter]: DirectionalHint.bottomCenter,\n  [DirectionalHint.bottomRightEdge]: DirectionalHint.bottomLeftEdge,\n  [DirectionalHint.bottomAutoEdge]: DirectionalHint.bottomAutoEdge,\n  [DirectionalHint.leftTopEdge]: DirectionalHint.rightTopEdge,\n  [DirectionalHint.leftCenter]: DirectionalHint.rightCenter,\n  [DirectionalHint.leftBottomEdge]: DirectionalHint.rightBottomEdge,\n  [DirectionalHint.rightTopEdge]: DirectionalHint.leftTopEdge,\n  [DirectionalHint.rightCenter]: DirectionalHint.leftCenter,\n  [DirectionalHint.rightBottomEdge]: DirectionalHint.leftBottomEdge,\n};\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nlet DirectionalDictionary: { [key: number]: PositionData } = {\n  [DirectionalHint.topLeftEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.top, 0, 0, 50, false),\n  [DirectionalHint.topCenter]: new PositionData(RectangleEdge.bottom, RectangleEdge.top, 50, 50, 50, false),\n  [DirectionalHint.topRightEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.top, 100, 100, 50, false),\n  [DirectionalHint.topAutoEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.top, 0, 0, 50, true),\n  [DirectionalHint.bottomLeftEdge]: new PositionData(RectangleEdge.top, RectangleEdge.bottom, 0, 0, 50, false),\n  [DirectionalHint.bottomCenter]: new PositionData(RectangleEdge.top, RectangleEdge.bottom, 50, 50, 50, false),\n  [DirectionalHint.bottomRightEdge]: new PositionData(RectangleEdge.top, RectangleEdge.bottom, 100, 100, 50, false),\n  [DirectionalHint.bottomAutoEdge]: new PositionData(RectangleEdge.top, RectangleEdge.bottom, 0, 0, 50, true),\n  [DirectionalHint.leftTopEdge]: new PositionData(RectangleEdge.right, RectangleEdge.left, 0, 0, 50, false),\n  [DirectionalHint.leftCenter]: new PositionData(RectangleEdge.right, RectangleEdge.left, 50, 50, 50, false),\n  [DirectionalHint.leftBottomEdge]: new PositionData(RectangleEdge.right, RectangleEdge.left, 100, 100, 50, false),\n  [DirectionalHint.rightTopEdge]: new PositionData(RectangleEdge.left, RectangleEdge.right, 0, 0, 50, false),\n  [DirectionalHint.rightCenter]: new PositionData(RectangleEdge.left, RectangleEdge.right, 50, 50, 50, false),\n  [DirectionalHint.rightBottomEdge]: new PositionData(RectangleEdge.left, RectangleEdge.right, 100, 100, 50, false)\n};\n\nlet CoverDictionary: { [key: number]: PositionData } = {\n  [DirectionalHint.topLeftEdge]: new PositionData(RectangleEdge.top, RectangleEdge.top, 0, 0, 50, false),\n  [DirectionalHint.topCenter]: new PositionData(RectangleEdge.top, RectangleEdge.top, 50, 50, 50, false),\n  [DirectionalHint.topRightEdge]: new PositionData(RectangleEdge.top, RectangleEdge.top, 100, 100, 50, false),\n  [DirectionalHint.topAutoEdge]: new PositionData(RectangleEdge.top, RectangleEdge.top, 0, 0, 50, true),\n  [DirectionalHint.bottomLeftEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.bottom, 0, 0, 50, false),\n  [DirectionalHint.bottomCenter]: new PositionData(RectangleEdge.bottom, RectangleEdge.bottom, 50, 50, 50, false),\n  [DirectionalHint.bottomRightEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.bottom, 100, 100, 50, false),\n  [DirectionalHint.bottomAutoEdge]: new PositionData(RectangleEdge.bottom, RectangleEdge.bottom, 0, 0, 50, true),\n  [DirectionalHint.leftTopEdge]: new PositionData(RectangleEdge.left, RectangleEdge.left, 0, 0, 50, false),\n  [DirectionalHint.leftCenter]: new PositionData(RectangleEdge.left, RectangleEdge.left, 50, 50, 50, false),\n  [DirectionalHint.leftBottomEdge]: new PositionData(RectangleEdge.left, RectangleEdge.left, 100, 100, 50, false),\n  [DirectionalHint.rightTopEdge]: new PositionData(RectangleEdge.right, RectangleEdge.right, 0, 0, 50, false),\n  [DirectionalHint.rightCenter]: new PositionData(RectangleEdge.right, RectangleEdge.right, 50, 50, 50, false),\n  [DirectionalHint.rightBottomEdge]: new PositionData(RectangleEdge.right, RectangleEdge.right, 100, 100, 50, false)\n};\n\nlet OppositeEdgeDictionary: { [key: number]: number } = {\n  [RectangleEdge.top]: RectangleEdge.bottom,\n  [RectangleEdge.bottom]: RectangleEdge.top,\n  [RectangleEdge.right]: RectangleEdge.left,\n  [RectangleEdge.left]: RectangleEdge.right,\n};\n\nexport module positioningFunctions {\n\n  export interface ICallout {\n    calloutRectangle: Rectangle;\n    calloutEdge: RectangleEdge;\n    targetEdge: RectangleEdge;\n    alignPercent: number;\n    beakPercent: number;\n  }\n\n  /**\n   * If max height is less than zero it returns the bounds height instead.\n   */\n  export function _getMaxHeightFromTargetRectangle(targetRectangle: Rectangle, targetEdge: DirectionalHint, gapSpace: number, bounds: Rectangle) {\n    let maxHeight = 0;\n\n    switch (targetEdge) {\n      case DirectionalHint.bottomAutoEdge:\n      case DirectionalHint.bottomCenter:\n      case DirectionalHint.bottomLeftEdge:\n      case DirectionalHint.bottomRightEdge:\n        maxHeight = bounds.bottom - targetRectangle.bottom - gapSpace;\n        break;\n      case DirectionalHint.topAutoEdge:\n      case DirectionalHint.topCenter:\n      case DirectionalHint.topLeftEdge:\n      case DirectionalHint.topRightEdge:\n        maxHeight = targetRectangle.top - bounds.top - gapSpace;\n        break;\n      default:\n        maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n        break;\n    }\n\n    return maxHeight > 0 ? maxHeight : bounds.height;\n  }\n\n  export function _getTargetRect(bounds: Rectangle, target: HTMLElement | MouseEvent) {\n    let targetRectangle: Rectangle;\n\n    if ((target as MouseEvent).preventDefault) {\n      let ev: MouseEvent = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n    } else {\n      targetRectangle = _getRectangleFromHTMLElement(target as HTMLElement);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      let outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (let direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n\n    return targetRectangle;\n  }\n\n  export function _getTargetRectDEPRECATED(bounds: Rectangle, targetElement?: HTMLElement, ev?: MouseEvent, targetPoint?: IPoint, isTargetPoint?: boolean): Rectangle {\n    let targetRectangle: Rectangle;\n\n    if (isTargetPoint) {\n      if (targetPoint) {\n        targetRectangle = new Rectangle(targetPoint.x, targetPoint.x, targetPoint.y, targetPoint.y);\n      } else {\n        let event = ev as MouseEvent;\n        targetRectangle = new Rectangle(event.clientX, event.clientX, event.clientY, event.clientY);\n      }\n    } else {\n      if (!targetElement) {\n        if (ev && ev.target) {\n          targetRectangle = _getRectangleFromHTMLElement(ev.target as HTMLElement);\n        }\n\n        targetRectangle = new Rectangle();\n      } else {\n        targetRectangle = _getRectangleFromHTMLElement(targetElement);\n      }\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      let outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (let direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n\n    return targetRectangle;\n  }\n\n  export function _getRectangleFromHTMLElement(element: HTMLElement): Rectangle {\n    let clientRect: ClientRect = element.getBoundingClientRect();\n\n    return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n  }\n\n  export function _positionCalloutWithinBounds(\n    calloutRectangle: Rectangle,\n    targetRectangle: Rectangle,\n    boundingRectangle: Rectangle,\n    directionalInfo: PositionData,\n    gap: number = 0,\n    coverTarget?: boolean,\n    directionalHintFixed?: boolean): ICallout {\n    let estimatedRectangle: Rectangle = _moveRectangleToAnchorRectangle(calloutRectangle,\n      directionalInfo.calloutDirection,\n      directionalInfo.calloutPercent,\n      targetRectangle,\n      directionalInfo.targetDirection,\n      directionalInfo.targetPercent,\n      gap);\n\n    if (_isRectangleWithinBounds(estimatedRectangle, boundingRectangle)) {\n      return { calloutRectangle: estimatedRectangle, calloutEdge: directionalInfo.calloutDirection, targetEdge: directionalInfo.targetDirection, alignPercent: directionalInfo.calloutPercent, beakPercent: directionalInfo.beakPercent };\n    } else {\n      return _getBestRectangleFitWithinBounds(\n        estimatedRectangle,\n        targetRectangle,\n        boundingRectangle,\n        directionalInfo,\n        gap,\n        coverTarget,\n        directionalHintFixed);\n    }\n  }\n\n  export function _getBestRectangleFitWithinBounds(\n    estimatedPosition: Rectangle,\n    targetRectangle: Rectangle,\n    boundingRectangle: Rectangle,\n    directionalInfo: PositionData,\n    gap: number,\n    coverTarget?: boolean,\n    directionalHintFixed?: boolean): ICallout {\n    let callout: ICallout = {\n      calloutRectangle: estimatedPosition,\n      calloutEdge: directionalInfo.calloutDirection,\n      targetEdge: directionalInfo.targetDirection,\n      alignPercent: directionalInfo.calloutPercent,\n      beakPercent: directionalInfo.beakPercent\n    };\n\n    // If it can't possibly fit within the bounds just put it into it's initial position.\n    if (!_canRectangleFitWithinBounds(estimatedPosition, boundingRectangle)) {\n      return callout;\n    }\n\n    if (!coverTarget && !directionalHintFixed) {\n      callout = _flipRectangleToFit(\n        callout,\n        targetRectangle,\n        directionalInfo.targetPercent,\n        boundingRectangle,\n        gap);\n    }\n\n    let outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(callout.calloutRectangle, boundingRectangle);\n\n    for (let direction of outOfBounds) {\n      callout.calloutRectangle = _alignEdgeToCoordinate(\n        callout.calloutRectangle,\n        (boundingRectangle as any)[RectangleEdge[direction]],\n        direction);\n      let adjustedPercent: number = _recalculateMatchingPercents(\n        callout.calloutRectangle,\n        callout.targetEdge,\n        targetRectangle,\n        callout.targetEdge,\n        directionalInfo.targetPercent);\n\n      callout.alignPercent = adjustedPercent;\n    }\n\n    return callout;\n  }\n\n  export function _positionBeak(beakWidth: number, callout: ICallout, targetRectangle: Rectangle, border: number): Rectangle {\n    let calloutRect: Rectangle = new Rectangle(\n      0,\n      callout.calloutRectangle.width - border * 2,\n      0,\n      callout.calloutRectangle.height - border * 2);\n    let beakRectangle: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n    let recalculatedPercent: number = _recalculateMatchingPercents(\n      callout.calloutRectangle,\n      callout.calloutEdge,\n      targetRectangle,\n      callout.targetEdge,\n      callout.beakPercent);\n    let estimatedTargetPoint: IPoint = _getPointOnEdgeFromPercent(calloutRect, callout.calloutEdge, recalculatedPercent);\n\n    return _finalizeBeakPosition(beakRectangle, callout, estimatedTargetPoint, border);\n  }\n\n  export function _finalizeBeakPosition(beakRectangle: Rectangle, callout: ICallout, estimatedTargetPoint: IPoint, border: number): Rectangle {\n    let beakPixelSize: number = _calculateActualBeakWidthInPixels(beakRectangle.width) / 2;\n    let innerRect: Rectangle | null = null;\n    let beakPoint: IPoint = { x: beakRectangle.width / 2, y: beakRectangle.width / 2 };\n\n    if (callout.calloutEdge === RectangleEdge.bottom || callout.calloutEdge === RectangleEdge.top) {\n      innerRect = new Rectangle(beakPixelSize, callout.calloutRectangle.width - beakPixelSize - border * 2, 0, callout.calloutRectangle.height - border * 2);\n    } else {\n      innerRect = new Rectangle(0, callout.calloutRectangle.width - border * 2, beakPixelSize, callout.calloutRectangle.height - beakPixelSize - border * 2);\n    }\n\n    let finalPoint: IPoint = _getClosestPointOnEdgeToPoint(innerRect, callout.calloutEdge, estimatedTargetPoint);\n\n    return _movePointOnRectangleToPoint(beakRectangle, beakPoint, finalPoint);\n  }\n\n  export function _getRectangleFromIRect(rect: IRectangle): Rectangle {\n    return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n  }\n\n  export function _finalizeCalloutPosition(calloutRectangle: Rectangle, hostElement: HTMLElement): Rectangle {\n    let hostRect: Rectangle = _getRectangleFromHTMLElement(hostElement);\n    let topPosition = calloutRectangle.top - hostRect.top;\n    let leftPosition = calloutRectangle.left - hostRect.left;\n\n    return new Rectangle(leftPosition, leftPosition + calloutRectangle.width, topPosition, topPosition + calloutRectangle.height);\n  }\n\n  /**\n   * Finds the percent on the recalculateRect that matches the percent on the target rect based on position.\n   */\n  export function _recalculateMatchingPercents(recalculateRect: Rectangle, rectangleEdge: RectangleEdge, targetRect: Rectangle, targetEdge: RectangleEdge, targetPercent: number): number {\n    let targetPoint: IPoint = _getPointOnEdgeFromPercent(targetRect, targetEdge, targetPercent);\n    let adjustedPoint: IPoint = _getClosestPointOnEdgeToPoint(recalculateRect, rectangleEdge, targetPoint);\n    let adjustedPercent: number = _getPercentOfEdgeFromPoint(recalculateRect, rectangleEdge, adjustedPoint);\n\n    if (adjustedPercent > 100) {\n      adjustedPercent = 100;\n    } else if (adjustedPercent < 0) {\n      adjustedPercent = 0;\n    }\n\n    return adjustedPercent;\n  }\n\n  export function _canRectangleFitWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n    if (rect.width > boundingRect.width || rect.height > boundingRect.height) {\n      return false;\n    }\n\n    return true;\n  }\n\n  export function _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n    if (rect.top < boundingRect.top) {\n      return false;\n    }\n    if (rect.bottom > boundingRect.bottom) {\n      return false;\n    }\n    if (rect.left < boundingRect.left) {\n      return false;\n    }\n    if (rect.right > boundingRect.right) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Gets all of the edges of a rectangle that are outside of the given bounds.\n   * If there are no out of bounds edges it returns an empty array.\n   */\n  export function _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n    let outOfBounds: RectangleEdge[] = new Array<RectangleEdge>();\n\n    if (rect.top < boundingRect.top) {\n      outOfBounds.push(RectangleEdge.top);\n    }\n    if (rect.bottom > boundingRect.bottom) {\n      outOfBounds.push(RectangleEdge.bottom);\n    }\n    if (rect.left < boundingRect.left) {\n      outOfBounds.push(RectangleEdge.left);\n    }\n    if (rect.right > boundingRect.right) {\n      outOfBounds.push(RectangleEdge.right);\n    }\n\n    return outOfBounds;\n  }\n\n  /**\n   * Returns a point on a edge that is x% of the way down it.\n   */\n  export function _getPointOnEdgeFromPercent(rect: Rectangle, direction: RectangleEdge, percentOfRect: number): IPoint {\n    let startPoint: IPoint;\n    let endPoint: IPoint;\n\n    switch (direction) {\n      case RectangleEdge.top:\n        startPoint = { x: rect.left, y: rect.top };\n        endPoint = { x: rect.right, y: rect.top };\n        break;\n      case RectangleEdge.left:\n        startPoint = { x: rect.left, y: rect.top };\n        endPoint = { x: rect.left, y: rect.bottom };\n        break;\n      case RectangleEdge.right:\n        startPoint = { x: rect.right, y: rect.top };\n        endPoint = { x: rect.right, y: rect.bottom };\n        break;\n      case RectangleEdge.bottom:\n        startPoint = { x: rect.left, y: rect.bottom };\n        endPoint = { x: rect.right, y: rect.bottom };\n        break;\n      default:\n        startPoint = { x: 0, y: 0 };\n        endPoint = { x: 0, y: 0 };\n        break;\n    }\n\n    return _calculatePointPercentAlongLine(startPoint, endPoint, percentOfRect);\n  }\n\n  /**\n   * Gets the percent down an edge that a point appears.\n   */\n  export function _getPercentOfEdgeFromPoint(rect: Rectangle, direction: RectangleEdge, valueOnEdge: IPoint): number {\n    switch (direction) {\n      case RectangleEdge.top:\n      case RectangleEdge.bottom:\n\n        return rect.width !== 0 ? (valueOnEdge.x - rect.left) / rect.width * 100 : 100;\n      case RectangleEdge.left:\n      case RectangleEdge.right:\n\n        return rect.height !== 0 ? (valueOnEdge.y - rect.top) / rect.height * 100 : 100;\n    }\n  }\n\n  /**\n   * Percent is based on distance from left to right or up to down. 0% would be left most, 100% would be right most.\n   */\n  export function _calculatePointPercentAlongLine(startPoint: IPoint, endPoint: IPoint, percent: number): IPoint {\n    let x: number = startPoint.x + ((endPoint.x - startPoint.x) * percent / 100);\n    let y: number = startPoint.y + ((endPoint.y - startPoint.y) * percent / 100);\n\n    return { x: x, y: y };\n  }\n\n  export function _moveTopLeftOfRectangleToPoint(rect: Rectangle, destination: IPoint): Rectangle {\n    return new Rectangle(destination.x,\n      destination.x + rect.width,\n      destination.y,\n      destination.y + rect.height);\n  }\n\n  /**\n   * Aligns the given edge to the target coordinate.\n   */\n  export function _alignEdgeToCoordinate(rect: Rectangle, coordinate: number, direction: RectangleEdge): Rectangle {\n    switch (direction) {\n      case RectangleEdge.top:\n\n        return _moveTopLeftOfRectangleToPoint(rect, { x: rect.left, y: coordinate });\n      case RectangleEdge.bottom:\n\n        return _moveTopLeftOfRectangleToPoint(rect, { x: rect.left, y: coordinate - rect.height });\n      case RectangleEdge.left:\n\n        return _moveTopLeftOfRectangleToPoint(rect, { x: coordinate, y: rect.top });\n      case RectangleEdge.right:\n\n        return _moveTopLeftOfRectangleToPoint(rect, { x: coordinate - rect.width, y: rect.top });\n    }\n\n    return new Rectangle();\n  }\n\n  /**\n   * Moves a point on a given rectangle to the target point. Does not change the rectangles orientation.\n   */\n  export function _movePointOnRectangleToPoint(rect: Rectangle, rectanglePoint: IPoint, targetPoint: IPoint) {\n    let leftCornerXDifference = rectanglePoint.x - rect.left;\n    let leftCornerYDifference = rectanglePoint.y - rect.top;\n\n    return _moveTopLeftOfRectangleToPoint(rect, { x: targetPoint.x - leftCornerXDifference, y: targetPoint.y - leftCornerYDifference });\n  }\n\n  /**\n   * Moves the given rectangle a certain number of pixels in the given direction;\n   */\n  export function _moveRectangleInDirection(rect: Rectangle, moveDistance: number, direction: RectangleEdge): Rectangle {\n    let xModifier: number = 0;\n    let yModifier: number = 0;\n\n    switch (direction) {\n      case RectangleEdge.top:\n        yModifier = moveDistance * -1;\n        break;\n      case RectangleEdge.left:\n        xModifier = moveDistance * -1;\n        break;\n      case RectangleEdge.right:\n        xModifier = moveDistance;\n        break;\n      case RectangleEdge.bottom:\n        yModifier = moveDistance;\n        break;\n    }\n\n    return _moveTopLeftOfRectangleToPoint(rect, { x: rect.left + xModifier, y: rect.top + yModifier });\n  }\n\n  /**\n   * Moves the given rectangle to an anchor rectangle.\n   */\n  export function _moveRectangleToAnchorRectangle(\n    rect: Rectangle,\n    rectSide: RectangleEdge,\n    rectPercent: number,\n    anchorRect: Rectangle,\n    anchorSide: RectangleEdge,\n    anchorPercent: number,\n    gap: number = 0): Rectangle {\n    let rectTargetPoint: IPoint = _getPointOnEdgeFromPercent(rect, rectSide, rectPercent);\n    let anchorTargetPoint: IPoint = _getPointOnEdgeFromPercent(anchorRect, anchorSide, anchorPercent);\n    let positionedRect = _movePointOnRectangleToPoint(rect, rectTargetPoint, anchorTargetPoint);\n\n    return _moveRectangleInDirection(positionedRect, gap, anchorSide);\n  }\n\n  /**\n   * Gets the closet point on an edge to the given point.\n   */\n  export function _getClosestPointOnEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: IPoint): IPoint {\n    switch (edge) {\n      case RectangleEdge.top:\n      case RectangleEdge.bottom:\n        let x: number;\n\n        if (point.x > rect.right) {\n          x = rect.right;\n        } else if (point.x < rect.left) {\n          x = rect.left;\n        } else {\n          x = point.x;\n        }\n        return { x: x, y: (rect as any)[RectangleEdge[edge]] };\n      case RectangleEdge.left:\n      case RectangleEdge.right:\n        let y: number;\n\n        if (point.y > rect.bottom) {\n          y = rect.bottom;\n        } else if (point.y < rect.top) {\n          y = rect.top;\n        } else {\n          y = point.y;\n        }\n        return { x: (rect as any)[RectangleEdge[edge]], y: y };\n    }\n  }\n\n  // Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n  // We still want to position the beak based on it's midpoint which does not change. It will\n  // be at (beakwidth / 2, beakwidth / 2)\n  export function _calculateActualBeakWidthInPixels(beakWidth: number): number {\n    return Math.sqrt(beakWidth * beakWidth * 2);\n  }\n\n  export function _getBorderSize(element: HTMLElement): number {\n    let styles: CSSStyleDeclaration = getComputedStyle(element, undefined);\n    let topBorder: number = parseFloat(styles.borderTopWidth || '');\n    let bottomBorder: number = parseFloat(styles.borderBottomWidth || '');\n    let leftBorder: number = parseFloat(styles.borderLeftWidth || '');\n    let rightBorder: number = parseFloat(styles.borderRightWidth || '');\n\n    // If any of the borders are NaN default to 0\n    if (isNaN(topBorder) || isNaN(bottomBorder) || isNaN(leftBorder) || isNaN(rightBorder)) {\n      return 0;\n    }\n\n    // If all of the borders are the same size, any value;\n    if (topBorder === bottomBorder && bottomBorder === leftBorder && leftBorder === rightBorder) {\n      return topBorder;\n    }\n\n    // If the borders do not agree, return 0\n    return 0;\n  }\n\n  export function _getPositionData(direction: DirectionalHint, target: Rectangle, boundingRect: Rectangle, coverTarget?: boolean): PositionData {\n    let directionalInfo: PositionData = coverTarget ? CoverDictionary[direction] : DirectionalDictionary[direction];\n\n    if (directionalInfo.isAuto) {\n      let center: IPoint = _getPointOnEdgeFromPercent(target, directionalInfo.targetDirection, 50);\n\n      if (center.x <= boundingRect.width / 2) {\n        directionalInfo.calloutPercent = 0;\n        directionalInfo.targetPercent = 0;\n      } else {\n        directionalInfo.calloutPercent = 100;\n        directionalInfo.targetPercent = 100;\n      }\n    }\n\n    return directionalInfo;\n  }\n\n  export function _flipRectangleToFit(callout: ICallout, targetRect: Rectangle, targetPercent: number, boundingRect: Rectangle, gap: number): ICallout {\n    let directions: RectangleEdge[] = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.top, RectangleEdge.bottom];\n    let currentEdge: RectangleEdge = callout.targetEdge;\n    // Make a copy to presever the original positioning.\n    let positionedCallout: ICallout = assign({}, callout);\n\n    // Keep switching sides until one is found with enough space. If all sides don't fit then return the unmodified callout.\n    for (let i = 0; i < 4; i++) {\n      let outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(positionedCallout.calloutRectangle, boundingRect);\n      let index: number = outOfBounds.indexOf(currentEdge);\n      let oppositeEdge: RectangleEdge = OppositeEdgeDictionary[currentEdge];\n\n      if (index > -1) {\n        directions.splice(directions.indexOf(currentEdge), 1);\n        currentEdge = directions.indexOf(oppositeEdge) > -1 ? oppositeEdge : directions.slice(-1)[0];\n        positionedCallout.calloutEdge = OppositeEdgeDictionary[currentEdge];\n        positionedCallout.targetEdge = currentEdge;\n        positionedCallout.calloutRectangle = _moveRectangleToAnchorRectangle(positionedCallout.calloutRectangle,\n          positionedCallout.calloutEdge,\n          positionedCallout.alignPercent,\n          targetRect,\n          positionedCallout.targetEdge,\n          targetPercent,\n          gap);\n      } else {\n        return positionedCallout;\n      }\n    }\n\n    return callout;\n  }\n}\n\nfunction getDirectionalHintForLayout(props: IPositionProps): DirectionalHint | undefined {\n  if (getRTL()) {\n    return props.directionalHintForRTL !== undefined ?\n      props.directionalHintForRTL :\n      MirrorDirectionalHintDictionary[props.directionalHint!];\n  } else {\n    return props.directionalHint;\n  }\n}\n\nexport function getRelativePositions(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  calloutElement: HTMLElement): IPositionInfo {\n  let beakWidth: number = !props.isBeakVisible ? 0 : (props.beakWidth || 0);\n  let borderWidth: number = positioningFunctions._getBorderSize(calloutElement);\n  let gap: number = positioningFunctions._calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  let boundingRect: Rectangle = props.bounds ?\n    positioningFunctions._getRectangleFromIRect(props.bounds) :\n    new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  let targetRect: Rectangle = props.target ? positioningFunctions._getTargetRect(boundingRect, props.target) : positioningFunctions._getTargetRectDEPRECATED(\n    boundingRect,\n    props.targetElement,\n    props.creationEvent,\n    props.targetPoint,\n    props.useTargetPoint);\n  let positionData: PositionData = positioningFunctions._getPositionData(\n    getDirectionalHintForLayout(props)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget);\n  let positionedCallout: positioningFunctions.ICallout = positioningFunctions._positionCalloutWithinBounds(\n    positioningFunctions._getRectangleFromHTMLElement(calloutElement),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    props.coverTarget,\n    props.directionalHintFixed);\n  let beakPositioned: Rectangle = positioningFunctions._positionBeak(beakWidth, positionedCallout, targetRect, borderWidth);\n  let finalizedCallout: Rectangle = positioningFunctions._finalizeCalloutPosition(positionedCallout.calloutRectangle, hostElement);\n\n  return {\n    calloutPosition: { top: finalizedCallout.top, left: finalizedCallout.left },\n    beakPosition: { top: beakPositioned.top, left: beakPositioned.left, display: 'block' },\n    directionalClassName: SLIDE_ANIMATIONS[positionedCallout.targetEdge],\n    submenuDirection: positionedCallout.calloutEdge === RectangleEdge.right ? DirectionalHint.leftBottomEdge : DirectionalHint.rightBottomEdge\n  };\n}\n\n/**\n * Get's the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(target: HTMLElement | MouseEvent, targetEdge: DirectionalHint, gapSpace: number = 0, bounds?: IRectangle) {\n  let mouseTarget: MouseEvent = target as MouseEvent;\n  let elementTarget: HTMLElement = target as HTMLElement;\n  let targetRect: Rectangle;\n  let boundingRectangle = bounds ?\n    positioningFunctions._getRectangleFromIRect(bounds) :\n    new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  if (mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else {\n    targetRect = positioningFunctions._getRectangleFromHTMLElement(elementTarget);\n  }\n\n  return positioningFunctions._getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle);\n}\n"]}